---
title: "Understanding mortality rates in BOP-operated prisons during 2020-2021"
author: Huo Jingnan and Nick McMillan
output:
  html_document:
    theme: cerulean
    code_folding: 
    toc: true
    toc_float: true
    toc_depth: 3
    df_print: paged
  md_document:
    variant: markdown_github
    toc: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, error = FALSE)
```


# Understanding mortality rates in BOP-operated prisons during 2020-2021 
NPR obtained a database of people who died in BOP-operated prisons through Freedom of Information Act requests filed by NPR, as well as requests filed by Professor Alison Guernsey at University of Iowa, shared with NPR. We compared mortality rates during 2020 and 2021 with previous years, adjusting for age. We found that mortality rates in BOP facilities in 2020 and 2021 have been significantly higher than the five years before the pandemic.

### Import Libraries

```{r}
library(tidyverse)
library(readxl)
library(lubridate)
library(jsonlite)
library(purrr)
library(janitor)
library(kableExtra)
library(knitr)

options(scipen = 100)

# Function for formatted table output

output_table = function(table){
  table %>% 
  kable() %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),font_size = 14, fixed_thead = T) %>% 
  scroll_box(width = "100%",height =  "500px")
  
}
```


### Importing death data

Death data preprocessing see separate notebook in main branch
```{r}

# death data obtained through two FOIA requests

death01 = read_csv('Jan2009-May2021 Deaths Analyzed - Copy.csv') %>% 
  slice(c(1:4507))
death02 = read_csv('20211217_2019_2021_deaths.csv')

# death data shared by Alison Guernsey at University of Iowa
death03 = read_csv('20220208_BOP_deaths_Apr_21_Jan_22.csv')

```


```{r}

# Clean Data

death01 = death01 %>% 
  mutate(api_actRelDate = lubridate::mdy(api_actRelDate),
         DOD = lubridate::mdy(DOD))

death02 = death02 %>% 
  mutate(api_actRelDate = lubridate::mdy(api_actRelDate),
         DOD = lubridate::ymd(DOD))

death03 = death03 %>% 
  rename('InstID' = 'faclCode',
         'RegisterNum' = 'BOP_RegisterNum',
         'DOD' = 'actRelDate',
         'api_age' = 'age',
         'api_sex' = 'sex',
         'api_race' = 'race') %>% 
  mutate(DOD = lubridate::mdy(DOD))



```

These deaths include privately operated facilities before 2019. We exclude them from the analysis because a) we don't have the post 2019 deaths in privately operated facilities, and b) situations in privately operated facilities are opaque, we have less on-the-ground reporting for them and don't know how similar they are to BOP-operated facilities.


```{r}

#stitching the three death databases together
deathmasterraw = bind_rows(death01, death02, death03)
```



```{r}

# cleaning up the columns as well as dropping duplicates - some of the requests have overlapping timeframes.

deathmaster = deathmasterraw %>% 
  select('InstID','RegisterNum','DOD','api_age','api_sex','api_race') %>%
  distinct() %>% 
  mutate(year = year(DOD))

```

```{r}
deathmaster %>% 
  group_by(year) %>% 
  count() %>% 
  output_table()


```


### Importing BOP prison population data
Sources - 
- JSON files collected by UCLA's COVID Behind Bars project
- Bureau of Prisons


#### UCLA's datasets
UCLA ran a scraper that collected json files from the BOP website.



```{r}

path <- "./ucla_files"
files <- dir(path, pattern = "*.json")
fullfilesnames = list.files(path, pattern = "*json", full.names = TRUE)


myJSON <- lapply(fullfilesnames, function(x) fromJSON(x)) # a list in which each element is one of the original JSON files

#
df_all_json = tibble() # create a nested data frame that combines all of the data frame

for (i in 1:length(myJSON)){
  
  df = myJSON[[i]]%>% 
  enframe %>% 
  pivot_wider(names_from = name, values_from = value)
  
  df_all_json = bind_rows(df_all_json, df)
  
}

# clean the data frame
df_all_json = df_all_json %>% 
  mutate(DATEMODIFIED = mdy(DATEMODIFIED)) %>% 
  mutate(year = year(DATEMODIFIED))

```
  
```{r}

#extract population totals
mainframe = df_all_json %>% 
  select(TOTALPOPULATION, BOPTOTAL, PRIVATETOTAL, DATEMODIFIED, year) %>% 
  rename(total_population = TOTALPOPULATION, bop_population = BOPTOTAL, private_population = PRIVATETOTAL, date = DATEMODIFIED ) %>% 
  mutate(population = as.numeric(bop_population))
  
```


```{r}

# extract the institution codes
bopfacmaster = tibble() 

for (i in 1:nrow(df_all_json)){
  
  df = df_all_json[[9]][[i]] # isolate the nested data frame
  year = df_all_json[[17]][[i]] 
  date_modified = df_all_json[[8]][[i]]
  
  df = df %>% 
    mutate(year = year, DATEMODIFIED = date_modified)
  
  bopfacmaster = bind_rows(bopfacmaster, df)
  
  
}

bopfacmaster = bopfacmaster %>% 
  distinct()


```

```{r}
glimpse(bopfacmaster) 
```


```{r}

instcnt = bopfacmaster %>% 
  distinct(year, code) %>% 
  group_by(year, code) %>% 
  count() %>%
  ungroup() %>% 
  group_by(year) %>% 
  count() 

# a facility is missing in 2022. But we aren't including them in the analysis.
instcnt %>% 
  output_table()






```



```{r}
bopcodes = unique(bopfacmaster$code)
length(bopcodes) # it looks like it's the same 122 facilities throughout the years.
```


```{r}
# using the BOP codes to filter out deaths in these facilities

deathmaster_bop = deathmaster %>% 
  filter(InstID %in% bopcodes)

```


```{r}
# check if any BOP facility hasn't had any deaths
bopcodes[!(bopcodes %in% unique(deathmaster_bop$InstID))]
```


#### BOP's datasets
BOP provided the population data broken down by age groups to NPR.<br>
The population totals supplement the json population count, and the age group distribution is used to calculate standardized mortality rate. BOP says these reports aren't necessarily on September 30, but a certain day in September that's close to it


```{r}

agedist = read_excel('tabula-Age_BOP_FY2015-21_cleaned.xlsx')

agedist = agedist %>% 
  group_by(year) %>% 
  mutate(frequency_overall = sum(Frequency)) %>% 
  ungroup() %>% 
  # calculate population percentage from raw numbers.
  mutate( percent = Frequency / frequency_overall) %>%
  # deselect the original percent column that was rounded
  select(-Percent) %>% 
  clean_names() %>% 
  rename(age_group = age) %>% 
  mutate(age_group = str_replace_all(age_group, ' ','')) %>% 
  mutate(age_group = str_replace_all(age_group, '-','–')) %>% 
  mutate(age_group = str_replace_all(age_group, '<=19','0–19'))

agedist %>% 
  output_table()

```

```{r}
# calculate population totals from the BOP data set 

reportcnt = agedist %>% 
  group_by(year) %>% 
  summarise(population = sum(frequency)) %>% 
  ungroup() %>% 
  rowwise() %>% 
  mutate(date_text = paste0('09/30/', toString(year))) %>% 
  mutate(date = mdy(date_text))

```

```{r}

# adding the BOP data to the UCLA data

popdf = full_join(mainframe, reportcnt) %>% 
  distinct()

popdf %>% 
  output_table()

```


```{r}
# check to see if the two datasets form a smooth curve. 

ggplot()+
  geom_line(data = mainframe, aes(x = date, y = population))+
  geom_point(data = reportcnt, aes(x = date, y = population))


```

### Computing annualized average prison population

Given prison population decreased significantly over the course of 2020 and 2021, we calculated an annualized average population for every year using all accessible datapoints throughout the year. We used linear interpolation and extrapolation to fill in the times when there's no data available.


#### Interpolate/extrapolate Jan 1 and Dec 31 values
To calculate an annualized average, we needed to make sure that every year has values for the first and last day of the year. This datapoint doesn't exist for every year, so we used interpolation and extrapolation to fill in the blanks

```{r}
interpolate_population = function(df, year_choice, mode){
  
  
  df_current = df %>% 
  filter(year == year_choice) %>% 
  arrange(date)



if (mode == "dec"){
  
  df_edge= df %>% 
    filter(year == year_choice+1) %>% 
    arrange(date) %>% 
    slice_head()

  df_current_edge = bind_rows(df_current, df_edge) %>% 
    arrange(date) %>% 
    slice(n() - 1,n()) %>% 
    arrange(date) %>% 
    mutate(x = c(0:1))
  
  first_day_next_year_date = df_current_edge %>% 
    slice(2) %>% 
    pull(date)
  
  last_day_this_year_date = df_current_edge %>% 
    slice(1) %>% 
    pull(date)
  
  # dec_31_this_year
  edge_date_this_year = paste0( year_choice, "-12-31")
  
  
  
  # calculate delta of days between first date of next year and last date of this year
  delta1 = as.numeric(difftime(ymd(first_day_next_year_date),
                   ymd(last_day_this_year_date),
                   units = "days"))
  
  # calculate delta of days between Dec 31 of this year and last date of this year
  delta2 = as.numeric(difftime(ymd(edge_date_this_year),
                   ymd(last_day_this_year_date),
                   units = "days"))
  
  edge_position = delta2/delta1
  
  
}

if (mode == "jan"){
  
  df_edge= df %>% 
    filter(year == year_choice - 1) %>% 
    arrange(date) %>% 
    slice_tail()
  
  df_current_edge = bind_rows(df_current, df_edge) %>% 
    arrange(date) %>% 
    slice(1,2) %>% 
    arrange(date) %>% 
    mutate(x = c(0:1))
    
  
  # calculate delta of days between first date of this year and last date of last year
  
  first_day_this_year_date = df_current_edge %>% 
    slice(2) %>% 
    pull(date)
  
  
  last_day_last_year_date = df_current_edge %>% 
    slice(1) %>% 
    pull(date) 
  
  # jan_1_this_year
  edge_date_this_year = paste0(year_choice, "-01-01")
  
  # calculate delta of days between first date of this year and last date of last year
  
  delta1 = as.numeric(difftime(ymd(first_day_this_year_date),
                   ymd(last_day_last_year_date),
                   units = "days"))
  
  #calculate delta of days between Jan 1 of this year and last date of last year
  
  delta2 =as.numeric(difftime(ymd(edge_date_this_year),
                   ymd(last_day_last_year_date),
                   units = "days"))
  
  
  edge_position = delta2/delta1
  
  
}


af <- approxfun(df_current_edge$x, df_current_edge$population)
  
edge_pop = af(edge_position)
  
df_edge_result = tibble(date = ymd(edge_date_this_year), 
                          population = edge_pop)

return(df_edge_result)
  
}
```



```{r}

# compute the interpolated or extrapolated values for Jan 1 and Dec. 31 of each year

years  = c(2015:2021)


df_bookends = tibble()

for (year_choice in years){
  
  # Interpolate for Dec 31 -----------------------
  
  check_dec_date = popdf %>% 
    filter(year == year_choice) %>% 
    arrange(date) %>% 
    slice(n()) %>% 
    pull(date)
  
  if (check_dec_date != paste0(year_choice, "-12-31")){
    
    dec_bookend = interpolate_population(popdf, year_choice, "dec")
    df_bookends = bind_rows(df_bookends, dec_bookend)
    
    
  }
}


  
  
  ## Interpolate for Jan 1. However, for 2015 since we don't have data for 2014 we will need to extrapolate

for (year_choice in years){
  
  check_jan_date = popdf %>% 
    filter(year == year_choice) %>% 
    arrange(date) %>% 
    slice(1) %>% 
    pull(date)
  
  # extrapolate for 2015
  if (year_choice == 2015) {
    
    last_day_this_year_date = popdf %>% 
    filter(year == 2015) %>% 
    arrange(date) %>% 
    slice_tail() %>% 
    pull(date)
    
    last_day_this_year_pop = popdf %>% 
    filter(year == 2015) %>% 
    arrange(date) %>% 
    slice_tail() %>% 
    pull(population)
    
    first_day_this_year_date = "2015-01-01"
    
    # calculate delta of days between first date of this year and beginning of this year 
    delta1 = as.numeric(difftime(ymd(last_day_this_year_date),
                   ymd(first_day_this_year_date),
                   units = "days"))
    
    pos1 = delta1/365
    
    dec31val = interpolate_population(popdf, 2015, "dec") %>% 
      pull(population)
    
    jan_extrapolate_date = tibble(
      x= c(pos1, 1),
      population = c(last_day_this_year_pop, dec31val)
    )
    
    our_model = lm(population ~ x, data = jan_extrapolate_date)
    jan1val = predict(our_model, newdata = data.frame(x = 0))
    
    jan_bookend = tibble( date = ymd(first_day_this_year_date),
                          population = jan1val )
     
    df_bookends = bind_rows(df_bookends, jan_bookend)
    
    
    
    
    
  }
  
  # interpolate for the rest
  else{
    
    if (check_dec_date != paste0(year_choice, "-01-01")){
    
    jan_bookend = interpolate_population(popdf, year_choice, "jan")
    df_bookends = bind_rows(df_bookends, jan_bookend)
    
     }
    
  }
    
}


df_bookends = df_bookends %>% 
  mutate(year = year(date))



  

```


```{r}
# add the computed bookends to the population counts
popdf1 = bind_rows(popdf, df_bookends)
```

#### Calculate an average yearly population with existing data points


```{r}


tot_pop_by_day = popdf1 %>% 
  arrange(date) %>% 
  group_by(year) %>% 
  mutate(avgpop = (population + lead(population)) / 2,
         days = as.numeric(difftime(ymd(lead(date)),
                   ymd(date),
                   units = "days")) ) %>%
  ungroup () %>% 
  mutate(popbbydays = avgpop * days)

avg_pop_df = tot_pop_by_day %>% 
  group_by(year) %>% 
  summarise(popbydays_total = sum(na.omit(popbbydays)),
            days_in_year = sum(na.omit(days))) %>% 
  ungroup() %>% 
  mutate(days_in_year_correct = days_in_year + 1) %>% 
  mutate(average_pop = popbydays_total / days_in_year_correct) %>% 
  select(year, average_pop)




```

```{r}
avg_pop_df %>% 
  output_table()
```

### Calculate standardized mortality ratio
#### Importing age percentage breakdown of prison population, provided by the BOP

```{r}

agedist1 = left_join(agedist, avg_pop_df, by = "year") %>% 
  mutate(group_pop = percent * average_pop)

agedist1 %>% 
  output_table()

```

#### Categorize age groups of each death


```{r}

agegroups = agedist1 %>% 
  distinct(age_group) %>% 
  separate(age_group, c("min_age", "max_age"), "–", remove = FALSE) %>% mutate(min_age = as.numeric(min_age), max_age = as.numeric(max_age))

deathmaster_bop = deathmaster_bop %>% 
  rowwise() %>% 
  mutate(age_group = case_when(
    api_age >= 0 & api_age <=19 ~ "0–19",
    api_age >= 20 & api_age <=24 ~ "20–24",
    api_age >= 25 & api_age <=29 ~ "25–29",
    api_age >= 30 & api_age <=34 ~ "30–34", 
    api_age >= 35 & api_age <=39 ~ "35–39", 
    api_age >= 40 & api_age <=44 ~ "40–44",
    api_age >= 45 & api_age <=49 ~ "45–49",
    api_age >= 50 & api_age <=54 ~ "50–54",
    api_age >= 55 & api_age <=59 ~ "55–59",
    api_age >= 60 & api_age <=64 ~ "60–64",
    api_age >= 65 & api_age <=69 ~ "65–69",
    api_age >= 70 & api_age <=74 ~ "70–74",
    api_age >= 75 & api_age <=79 ~ "75–79",
    api_age >= 80 & api_age <=84 ~ "80–84",
    api_age >= 85 & api_age <=89~ "85–89",
    # since BOP's age frequency distribution did not include people aged 95 and above, we assume that they are counted in the highest age category possible
    api_age >= 90 ~ "90–94",
    TRUE ~ "not-found"))
    
deathmaster_bop %>% 
  filter(api_age > 95)  %>% 
  output_table()
    


```

#### Calculate Mortality year to year
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3406211/


```{r}



death_year_age = deathmaster_bop %>% 
  group_by(year, age_group) %>% 
  summarise(deaths = n())


```

```{r}

agedist2 = left_join(agedist1, death_year_age, by = c("age_group", "year"))
agedist2[is.na(agedist2)] <- 0


# calculate death rate for each age group
agedist2 = agedist2 %>% 
  mutate(mortality_per_100k = (deaths / group_pop)*100000,
         mortality_rate = deaths/group_pop) 

agedist2 %>% 
  output_table()


```

```{r}
df = agedist2 %>% 
  pivot_wider(id_cols = age_group, names_from = year, values_from = mortality_per_100k)

df %>% 
  output_table()

```

### Compare mortality rates during pandemic and five years prior
#### 2020 to 2015-2019
We used population between 2015 and 2019 as reference.

We also considered using US population as a reference population. Similar to previous studies, we found that expected deaths exceed actual deaths when using the US population as a reference. One of the reasons may be that many causes of death in the general population, like car accidents, don't exist in incarcerated environments.


```{r}

ref = agedist2 %>% 
  filter(year <2020)

```

```{r}
std = ref %>% 
  group_by(age_group) %>% 
  summarise(deaths_sum = sum(deaths),
            group_pop_sum = sum(group_pop)) %>% 
  ungroup() %>% 
  mutate(expected_death_rate = deaths_sum / group_pop_sum,
         per_100k = expected_death_rate*100000)

```



```{r}
yr20 = agedist2 %>% 
  filter(year == 2020) %>% 
  select(age_group, group_pop, deaths, mortality_rate)S


```



```{r}

std1 = left_join(std, yr20, by = "age_group")
std1 = std1 %>% 
  mutate(expected_deaths = group_pop * expected_death_rate)


```

```{r}
sum(na.omit(std1$deaths))/sum(na.omit(std1$expected_deaths))-1
```

```{r}
sum(na.omit(std1$expected_deaths))
```

#### Compare 2021  to 2015-2019

```{r}

yr21 = agedist2 %>% 
  filter(year == 2021) %>% 
  select(age_group, group_pop, deaths, mortality_rate)

```

```{r}
std21 = left_join(std, yr21, by = "age_group")
std21 = std21 %>% 
  mutate(expected_deaths = group_pop * expected_death_rate)


```

```{r}

sum(na.omit(std21$deaths))/sum(na.omit(std21$expected_deaths))-1
```

#### Combining 2020 and 2021

```{r}

((sum(na.omit(std21$deaths)) + sum(na.omit(std1$deaths)))/2)/((sum(na.omit(std21$expected_deaths)) + sum(na.omit(std1$expected_deaths)))/2) - 1

```



### Comparing age-adjusted mortality rates
Using age distribution in 2015-2019 as weights

```{r}
# examining age distribution of all years
years = c(2015:2021)

for(year in years){
  
  plot = agedist2 %>% 
    filter(year == year) %>% 
    ggplot(aes(x = age_group, percent, fill= age_group))+
    geom_bar(stat = "identity")+
    ggtitle(paste0(year))
  
  print(plot)
  
  
}


```

```{r}
# calculating the age-specific death rates in the refernce population - 2015-2019

std = ref %>% 
  group_by(age_group) %>% 
  summarise(group_pop = sum(group_pop), average_pop = sum(average_pop), deaths = sum(deaths))



```


```{r}
std = std %>% 
  mutate(death_rate = deaths / group_pop,
         pop_pct = group_pop / average_pop,
         weighted_rate = death_rate * pop_pct)

```


```{r}

std %>% 
  output_table()

```
```{r}

sum(std$weighted_weight)*100000
```
#### Calculating age-adjusted death rate in 2020

```{r}

yr20_3 =  left_join(yr20, std, by = "age_group") %>% 
  mutate(weighted_rate = mortality_rate * pop_pct)

yr20_3 %>% 
  output_table()


```

```{r}

sum(yr20_3$weighted_rate)*100000


```

```{r}
# difference between 2020 and 2015-2019

sum(yr20_3$weighted_rate)/sum(std$weighted_rate)-1

```
#### calculating 2021

```{r}

yr21 = yr21 %>% 
  mutate(mortality_rate = deaths / group_pop)

```

```{r}

yr21_3 = left_join(yr21, std, by = "age_group")
yr21_3  = yr21_3 %>% 
  mutate(weighted_rate = mortality_rate * pop_pct)


yr21_3 %>% output_table()

```

```{r}
sum(yr21_3$weighted_rate)

```

```{r}
# difference between 2021 and 2015-2019
sum(yr21_3$weighted_rate)/sum(std$weighted_rate)-1

```

